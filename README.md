https://deepmind.google/discover/blog/genie-2-a-large-scale-foundation-world-model/
GM 초밥어부의 패악질로 개발 드롭
----------------------- February 1st 2024(Friday) Devlog---------------------

https://silky-number-76b.notion.site/footmadegames-footmadegames-Terms-of-Use-8ce445930ec44d058f838bf27388e9e4


----------------------- January 26th 2024(Friday) Devlog---------------------

https://support.google.com/googleplay/android-developer/answer/9898783?sjid=3863523683107161299-AP#zippy=%2C%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%9C%84%EB%B0%98-%EC%82%AC%EB%A1%80


To address the rejection of your mobile game "Upperwell" from Google Play due to policy violations, you'll need to carefully review and correct the specific issues related to the Broken Features Policy and Metadata Policy.1. **고장난 기능 정책 위반 해결하기**:
   - 앱을 철저히 테스트하여 모든 버그와 오류를 식별하십시오. 게임이 모든 화면 크기와 장치에서 제대로 작동하는지 확인합니다.
   - 문제가 발생하는 기능이나 부분을 수정하고, 필요한 경우 Unity 엔진을 사용하여 게임을 최적화하십시오.
   - 수정 후, 게임을 여러 장치와 버전의 Android에서 테스트하여 문제가 해결되었는지 확인합니다.
2. **메타데이터 정책 위반 해결하기**:
   - Google Play의 메타데이터 가이드라인을 다시 확인하십시오. 이는 앱의 제목, 설명, 스크린샷 등이 포함됩니다.
   - 오해의 소지가 있는 단어, 과장된 설명, 불필요한 키워드 누적(키워드 스태핑) 등을 피하십시오.
   - 스크린샷과 비디오가 실제 게임 플레이를 정확하게 반영하는지 확인하고, 모든 그래픽 자료가 적절하고 관련성이 있는지 확인합니다.

3. **재검토 요청**:
   - 모든 수정이 완료된 후, Google Play Console을 통해 앱을 다시 제출하십시오.
   - 재검토 요청 시, 어떤 부분을 수정했는지 명확하게 기술하고, Google Play 정책 준수를 위한 노력을 강조합니다.

4. **앞으로의 관리**:
   - 정기적으로 앱을 업데이트하고 최적화하여 이러한 문제가 재발하지 않도록 합니다.
   - Google Play의 정책 변경 사항을 주기적으로 확인하여 앱이 지속적으로 규정을 준수하도록 합니다.

Google Play에서 앱이 거부된 경우, 구체적인 위반 사항에 대한 해결책을 제시하는 것이 중요합니다. 만약 더 자세한 정보가 필요하거나 구체적인 위반 사항을 이해하는 데 어려움이 있다면, Google Play 개발자 지원팀에 문의할 수도 있습니다.




----------------------- January 16~19th 2024(Wednesday, Friday) Devlog---------------------
퀀텀 장풍을 쏘면서 적과 벽을 부수며 상승하는 볼럼블의 모험
볼럼블: 양자 장풍을 쏘면서 적과 벽을 부수며 더 멀리 상승하자.
.
적과 벽을 부수고, 빠르게 올라가고, 인상적인 콤보를 쌓는 게임


이 게임은 초밥키우기 유니버스 배경의 팬픽게임입니다.

초키 게임 세계에서 떠돌던 볼럼블은 발을 헛딛게 되어, 심연의 오마카세까지 추락하게 되게 됩니다. 그래서 다시 돌아가기 위해 모험을 떠납니다. 

 볼럼블은 '양자 장풍'을 발사해서 상승하며 벽을 뚫고, 가속하여 가능한한,  빠르게 위로 올라가고, 생명게이지(HP)인  콤보게이지를 유지 할 수 있도록 나름, 역동적인 게임 플레이 메커니즘을 추구합니다,


‘’

알고 지내는 결혼한 커플이 있습니다.
1년전만 하더라도.. 남자는 군대에 가있고, 집 월세며 생활비를 모두 여자가 부담하는 상황이였죠..
1년전에도 유튜브를 하고 있긴 했었는데...그때는 구독자가 2~3만명 정도? 어느덧 꾸준히 구독자가 늘어서 지금은 구독자가 32만명이더군요 
구독자...30만명이면 대략적으로 월 수입이 얼마정도 되려나요
남녀 둘다 특정한 직업이 없고... 지금 현재는 유튜브를 통해서만 수익활동을 하는듯 싶구요
물론, 조회수, 광고 시청, 영상재생 시간 등등에 따라서 유동적으로 채널마다 수입이 다르게 책정되는건 알고 있지만.... 

그래도 30만정도면 어느정도 수입일지 궁금해 지더군요..
1년사이에 집도 거의 2.5~3배 더 큰 집으로 이사를 하기도 했고...(1년전 살던 집이 워낙 작았...)
오늘 보니까.. 여친에게 100 만원어치 옷선물을 해줬다는 영상을 올렸더군요..
어쨌든 1년전까지만 해도... 둘다 나이도 20초반으로 어리고 경제적으로도 힘든 상황속에서 

사귀고 결혼하고 하는 모습들이 대단해 보이기도 하고...걱정도 되고는 했는데..
어느덧 집도 큰집으로 옮기고.. 제법 여유있어 보여서 마음이 놓이고 잘돼서 보기 좋네요...

너튜브가 하나의 선망의 직업(?)이 된후로... 주변에 너튜브 하겠다는 사람들을 수도 없이 봤는데

다들 몇달 하다가...구독자도 안늘고, 수입도 거의 없다보니.... 일년도 못가서 때려치우는게 대부분인 상황들을 자주 봐오다가

유튜버 활동을 통해서 어느정도 자리를 잡은 아는 커플을 보니까.....기분이 오묘~합니다. 


 2019-09-13 20:59:30
기본 한달 1500 은 넘을거 같은데요 ㅠ

안녕내사탕님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.WR
 2019-09-13 21:02:35
저도 나름...저만(?) 할수 있는 흥미로운 컨텐츠가 있어서.... 주변에서 항상 저보고 너튜브 하면 괜찮을거 같다라고 말하곤 하는데... 영상 찍는것도, 편집하는것도 귀찮아서. 단호하게 난 안해. 관심없어. 이렇게만 대답했었는데.... 직접 알고 지내는 주변 친구가 30만 구독자 만들고 생활하는거 보니까... 살~~~~~짝 너튜브 해볼까 하는 생각이 들긴 드네요...ㅎㅎ 

임스님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:05:47
당연히 해야죠...한달에 1500마넌인데...포기하실거에요???

임스님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:02:43
우어....그정도인가요??? 엄청나군요..그래서 다들....

애인자인항애지님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:02:02
 왁싱 했을가요 ?

참 곱네 

안녕내사탕님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.WR
 2019-09-13 21:03:25
포토샵으로 곱게 만들수 있.......쿨럭~ 

애인자인항애지님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:04:46
어쨋든 ㄳ 

사과로님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:13:01
오마르라는 유투버는 구독자 10만에 월수익 156만이었구요

쏘이라는 유투버는 구독자 7만에 월수익 218만이었습니다

오마르가 구독자가 더 많은데 수익이 적은 이유는 광고를 더 적게 게시했다고 합니다.

컨텐츠에따라 원작자가 있는거라면 (ex, 다른가수의 노래 커버곡) 수익 일부가 원작자에게로 가기때문에 그분이 어떤 주제로 활동하는지에따라 수익도 다르겠네요,

오마르님 기준의 광고수익으로 계산하면 월 500가까이 벌겠구

쏘이님 기준의 수익이라면 월 700정도 될것같습니다

안녕내사탕님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.WR
 2019-09-13 21:19:01
네..광고. 조회수. 기타등등에 따라 같은 구독자라도 수익이 천차만별이긴 하죠...^
 

룰루아빠님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.
1
 Updated at 2019-09-13 21:15:00
구독자 30만 정도면 구독자 수는 크게 의미가 없고(영상 조회수가 얼마 안 나올 테니) 영상에 연계된 쇼핑몰이나 제휴 링크 등 기타 소득이 있어야 할 거예요. 영상에 거는 광고로 버는 수익은 많지 않습니다. 제가 알기로 순수 유튜브 영상만으로는 30만 정도 구독자로 한 가정이 먹고 살 만큼의 수익은 나오지 않아요.

안녕내사탕님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.WR
 2019-09-13 21:21:03
너튜브 수입이라는게 워낙... 이것 저것 연계되고 복잡하게 얽혀서 산출되는거라... 저도 잘 알지는 못하지만..

위에 사과로님 리플 말씀대로라면 적어도 월 500 이니까.. 두 식구 살만큼의 수입은 되지 않을까요...

그리고 제가 아는 또다른 너튜브 하는 친구는 구독자 4만명인데도... 다른일 안하고 전업으로 하고 있기도 하구요..^^;

보람찬님의 프로필 이미지입니다. 클릭하시면 원본을 보실 수 있습니다.
 2019-09-13 21:20:18
동네 초등학생 장래희망 물어보니 유튜버라고 하더군요.

30만명 구독자 이루기까지 놀고먹진 않았을 겁니다. 나름의 강점이 있으리라 생각됩니다. 콘텐츠, 편집...

 2019-09-13 21:21:37
저희 누나네  아이들도... 장래희망이 유투버.....크리에이터.... 라고 하더군요..^^;

Sailor님은 아직 프로필 이미지를 등록하지 않으셨습니다.
 2019-09-13 21:20:54
월 200만원 정도 예상해봅니다.


 2019-09-13 21:22:15
첫번째 리플 월 1500만원에서... 

지금 리플말씀 200만원까지.... 역시 유튜브 수입 계산은 난해하고 복잡하고 어렵군요..^^


 Updated at 2019-09-13 21:43:32
일단 확실한게 제 후배가 10만구독자인데 300~500만원 꾸준하게 들어옵니다 구독보다는 꾸준한 조회수와 실 시청시간이 중요하구요 그리고 구독자가 많으면 그만큼 조회수가 나오니깐 이게 일종의 지표는 되지요 그리고 제 주위 30만 기준으로 예를 들면 보통 800~1000만원 수익은 따라오더군요 카더라가 아니라 지인들 실 수익입니다 적어도 매주 1회 이상의 지속적인 컨텐츠 그리고 꾸준한 조회수가 돈이 됩니다 구독자가 50만이더라도 귀찮아서 업로드 영상을 어쩌다 올리는 이 친구는 100만원이 되기도 합니다

 2019-09-13 21:40:39
꾸준한 업로드 그리고, "누적 시청시간" 이 중요하고, "장르" 또한 중요하죠 .- 광고가 잘 붙는 "장르" 를 선택하는 것도 하나의 요령 

 2019-09-13 21:47:28
구독자 수가 중요하지 않다고 하시는데 어떤 면에선 맞고 어떤 면에선 틀린 이야기입니다
구독자 수가 많다고 무조건 수익이 들어오진 않죠 수익은 조회수에서 나오는 거니까
하지만 구독자 수가 중요한게 구독자가 많으면 그만큼 광고도 더 많이 들어오고

구독자가 많다는건 그 구독자 중 다수는 그 영상을 볼거란 이야기가 되니까요
사실 구독자 30만명이면 우리나라 유튜버 중 상당히 상위권에 들어가는 걸로 알고 있어요
구독자 30만 넘는 우리나라 유튜버 따지면 그리 많지 않을 걸요?

좀 더 정확히는 조회수가 아니라 그 영상에 붙는 광고인데...
조회수가 많을 수록 광고가 더 붙으니까요

 2019-09-13 21:49:21
하이라이트 포텐 터지면 눈 굴러가듯 뽕을 뽑죠 그레서 크레이터는 자극적인 컨텐츠 유혹과 싸움이죠

 2019-09-14 00:33:56
구독자 20만 넘어서면 본격적으로 '전업'고민을 한다고 합니다. 30만이면 웬만한 자영업자 궤도에 올라섰다 보면 됩니다.

 2019-09-14 02:40:03
조카가 유튜버인데 구독자 80만(인줄알았는데 지금보니 91만 넘었네요)이라해서 요래저래 추정해보니 월 7000~1억 사이 버는거같아요. 조만간 빌딩올린다 하대요.ㅡ

구독자랑 수익이랑 직접적으로 연관은 없는걸로 압니다. 제가 구독하는 유튜버가 구독자수가 60만명인데 수익공개했을때 월 300도 안되던데요. 그 이유가 뭐 영상시간과 광고삽입 조회수등등 연관이 있다고 하더라구요.
그리고 위에분이 30만명 구독자를 가진 유튜버가 상위권이라 하셨는데 이만큼 구독자를 가진 유튜버들 생각보다 많아요 상위권도 아니구요---- 

상기 게시물 등의 글들을 참고해서 현재 구독자 17만명을 가진 유튜버 공룡아빠의 월 수입을 대략적으로 재미로 추정해봅시다.'

---------------------October 10-12,25th 2023(Monday-Wednesday) Devlog---------------------
ballrumble: 오랜만에 업데이트를 하려니 유니티



--------------------------October 6~7th 2023(Thursday, Friday) Devlog-----------------------

https://ssscool.tistory.com/673

[Unity] Job failed with exception: System.Reflection.TargetInvocationException  
오랜만에 업데이트를 하려니 유니티 버전을 업그레이드 해서 그런지 원래 안뜨던 에러가 뜬다
 
 
Job failed with exception: System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---> System.InvalidOperationException: Insecure connection not allowed
  at (wrapper managed-to-native) UnityEngine.Networking.UnityWebRequest.BeginWebRequest(UnityEngine.Networking.UnityWebRequest)
  at UnityEngine.Networking.UnityWebRequest.SendWebRequest () [0x00001] in <7bd1a2deca0f4abca7e2e5a91994141b>:0 
  at (wrapper managed-to-native) System.Reflection.RuntimeMethodInfo.InternalInvoke(System.Reflection.RuntimeMethodInfo,object,object[],System.Exception&)
  at System.Reflection.RuntimeMethodInfo.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x0006a] in <b89873cb176e44a995a4781c7487d410>:0 
   --- End of inner exception stack trace ---
  at System.Reflection.RuntimeMethodInfo.Invoke (System.Object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) [0x00083] in <b89873cb176e44a995a4781c7487d410>:0 
  at System.Reflection.MethodBase.Invoke (System.Object obj, System.Object[] parameters) [0x00000] in <b89873cb176e44a995a4781c7487d410>:0 
  at Google.PortableWebRequest.StartRequest (Google.PortableWebRequest+HttpMethod method, System.String url, System.Collections.Generic.IDictionary`2[TKey,TValue] headers, UnityEngine.WWWForm form) [0x0019e] in /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/PortableWebRequest.cs:508 
  at Google.PortableWebRequest+<StartRequestOnMainThread>c__AnonStorey6.<>m__C () [0x00000] in /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/PortableWebRequest.cs:458 
  at Google.RunOnMainThread.ExecuteNext () [0x0003d] in /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:486 
UnityEngine.Debug:LogError (object)
Google.RunOnMainThread:ExecuteNext () (at /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:488)
Google.RunOnMainThread:<ExecuteAllUnnested>m__12 () (at /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:536)
Google.RunOnMainThread:RunAction (System.Action) (at /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:343)
Google.RunOnMainThread:ExecuteAllUnnested (bool) (at /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:530)
Google.RunOnMainThread:ExecuteAll () (at /Users/chkuang/Workspace/git/unity-jar-resolver/source/VersionHandlerImpl/src/RunOnMainThread.cs:512)
UnityEditor.EditorApplication:Internal_CallUpdateFunctions () 
 
Edit > Project Settings > Player > Other Settings > Configuration > Allow downloads over HTTP 
Always allowed


Always allowed 로 바꾸면 에러가 사라진다.
 참고
https://forum.unity.com/threads/job-failed-with-exception-system-reflection-targetinvocationexception-unity-error.1294134/

--------------------------September 25~27th 2023(Monday~Wed) Devlog-----------------------
ballrumble  공부양 gkf tn dkTpRma ehdhkwnsms zhem
발사시 공중 부양을 하게끔 도와주는 코드 작성.


--------------------------September 22nd 2023(Friday) Devlog-----------------------
0, GMfisher.cs
이벤트 코드 작성,이 스크립트를 사용하려면, 유니티 에디터에서 GMfisher 객체에 GMfisher 스크립트를 추가하고, player 변수에 플레이어 객체를 할당해야 합니다. 또한, 레이저 프리팹과 레이저 스폰 지점도 설정해야 합니다.
또한, ballrumble 스크립트에서 조작을 비활성화하면 해당 스크립트의 모든 코드가 실행되지 않습니다. 만약 일부 코드가 계속 실행되어야 한다면, 그 부분을 별도의 스크립트로 분리하거나 조건문을 사용하여 해당 코드만 실행되도록 할 수 있습니다.

1, EnemySpawn,cs 하기 코드 삭제 ()
 /*    public void Update()
    {
        fGametime = Time.time;

        if (fGametime >= nextSpawnTime)
        {
            Vector2[] spawnPoints0 = {
            new Vector2(Spawn_HorizontalLeft, Random.Range(Spawn_VerticalBottom, Spawn_VerticalTop) + this.transform.position.y),
            new Vector2(Spawn_HorizontalRight, Random.Range(Spawn_VerticalBottom, Spawn_VerticalTop) + this.transform.position.y),
            new Vector2(Random.Range(Spawn_HorizontalLeft, Spawn_HorizontalRight)  + this.transform.position.x,

            Spawn_VerticalTop),
            new Vector2(Random.Range(Spawn_HorizontalLeft, Spawn_HorizontalRight)+ this.transform.position.x, Spawn_VerticalBottom)
        };
            Vector2[] spawnPoints1 =
                {
                };

            fLeveling = fGametime / 5;//시간이 지날 수록 난이도를 상승시킨.
            Vector2 lv1spawnPosition = spawnPoints0[Random.Range(0, spawnPoints0.Length)]; //footman 중구난방하게 나오는 풋맨 스폰 위칟
            Vector2 lv2spawnPosition;// = spawnPoints1[Random.Range(0, spawnPoints1.Length)]; //wingman 은 좌우하 끝쪽에서 스폰시, pc의 position.y+1~3를 기억하여 spawn


            if (fLeveling <= 1) // 10으로 나눠서 1이하 인 경우, 풋맨 
            
                Instantiate(enemyPrefabs[0], lv1spawnPosition, Quaternion.identity);

            //SpawnEnemy();

            nextSpawnTime = fGametime + 1f / spawnRate; 
        }

    }
    */   /*
    void SpawnEnemy()
    {
        Vector2[] spawnPoints = {
            new Vector2(-20, Random.Range(-25, 25)),
            new Vector2(20, Random.Range(-25, 25)),
            new Vector2(Random.Range(-15, 15), 25),
            new Vector2(Random.Range(-15, 15), -25)
        };

        Vector2 spawnPosition = spawnPoints[Random.Range(0, spawnPoints.Length)];
        Instantiate(enemyPrefabs[0], spawnPosition, Quaternion.identity);
    } */
--------------------------September 21th 2023(Thursday) Devlog —------------------------
tomas가 만든 게임
https://ldjam.com/events/ludum-dare/45/orudo-taima?fbclid=IwAR2TEi9xXlGgr4nl66PLd-dOGt6h1en7s6mnn06X8HQdkoHt4VTnLD4XtOw

1, URP 취소 모두 삭제 (2D Shader  삭제)
2,,  Enemy Code clean up
/*public class Enemy : MonoBehaviour
{
    public int nHp = 1;
    public EnemyKind enemykind;
    public float moveDistance = 4f; // 왼쪽과 오른쪽으로 움직일 거리
    public float moveSpeed = 2.0f; // 움직임의 속도
    private Vector3 originPosition; // 적의 원래 위치
    public bool bMovingRight = true; // Flag to determine the movement direction
    public Rigidbody2D rb;
public float fCheckdisfordic;
    void Start()
    {
        originPosition = transform.position; // Store the original position
    }


  void Update()
    {
    // 움직임의 방향을 기반으로 목표 위치 결정
                Vector3 targetPosition = bMovingRight ? originPosition + new Vector3(moveDistance, 0, 0) : originPosition - new Vector3(moveDistance, 0, 0);

                // 목표 위치로 적 움직임
                transform.position = Vector2.MoveTowards(transform.position, targetPosition, moveSpeed * Time.deltaTime);
                fCheckdisfordic = Vector2.Distance(transform.position, targetPosition);
                // 적이 목표 위치에 도달했는지 확인
                if (fCheckdisfordic < 2.3f)
                {
                    // 움직임의 방향 반전
                    bMovingRight = !bMovingRight;
                    gameObject.GetComponent<SpriteRenderer>().flipX = !gameObject.GetComponent<SpriteRenderer>().flipX;
                }
                
    
   
    }
    public void Dead()
    {

        this.gameObject.GetComponent<SpriteRenderer>().color = Color.red;
        Destroy(this.gameObject, 0.5f);
       // Destroy(this.gameObject);
    }

    public void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.transform.tag == "PMissile")
        {

            Debug.LogWarning("(적) 죽음음.GameManager.Instance.AddScore();");
            GameManager.Instance.AddScore();
            Dead();
            
        }  
    }
    public void OnCollisionExit2D(Collision2D collision){}
            
    
}
*/


-----------------------September19,20th 2023(Tuesday,wednesday) Devlog-----------------------

1, EnemySpawn.cs 코딩 보완중 생각보다 복잡
- ㅇㅇㅇ

2. code 삭제
 (ballrumble.cs) 
void Update()
    {       if (Input.GetKeyDown(KeyCode.Space)) // (bJumpOK == true) &&
        {
            /*
            Vector2 dic_aim = Aim.transform.position - this.transform.position;
            // dic_aim = -dic_aim;

            GameObject missile = Instantiate(missilePrefab, missileSpawnPoint.position, Quaternion.identity);
            Rigidbody2D missileRb = missile.GetComponent<Rigidbody2D>();    //  Vector2 shootDirection = transform.Find("DIO").up;
            rb.AddForce(-dic_aim.normalized * fJumpPower, ForceMode2D.Impulse);
            missileRb.AddForce(dic_aim.normalized * missileForce, ForceMode2D.Impulse);

            Dash_fDeltatime = 0;
            fFillTimer = 0f;
            bJumpOK = false;
            */
            OnShot();        }
2) EnemySpawn.cs 
     /*            new Vector2(Spawn_HorizontalLeft, Random.Range(-25, 25)),
            new Vector2(Spawn_HorizontalRight, Random.Range(-25, 25)),
            new Vector2(Random.Range(-15, 15), Spawn_VerticalTop),
            new Vector2(Random.Range(-15, 15), Spawn_VerticalBottom)
			*/


1, 이펙트 카툰 이펙트 웹GL 시연 사이트
https://jeanmoreno.com/unity/cartoonfx/

지금 기능 들만 만들고 놓고 (제네널 템플릿)레벨디자인, 밸런스 디자인은 전혀 안한 상태에요
일단 손맛이 이 게임의 중요한 요소인데 개발내내 계속 알앤디 할듯 하군요..  게임을 해보니  다운웰 처럼 하단을 쏘는 형태 즉 전폭기의 달린 뒷기관총 같이 되어야 한다. 따라오는 것들을 추격해오는 것들을 처치하는 것. 위에 레벨보다 올라오는 것에 대한 레벨디자인이 필요한듯 하다.
게임을 해보니  다운웰 처럼 하단을 쏘는 형태 즉 전폭기의 달린 뒷기관총 같이 되어야 한다. 
따라오는 것들을 추격해오는 것들을 처치하는 것. 
위에 레벨보다 올라오는 것에 대한 레벨디자인이 필요한듯 하다.

1)지금 기능 들만 만들고 놓고 (제네널 템플릿)
2)레벨디자인, 밸런스 디자인
3) 조작감 
일단 손맛이 이 게임의 중요한 요소인데 개발내내 계속 알앤디 보완


--------------------------September 18th 2023(Monday) Devlog--------------------------

1) auto aim, shooting, 
2)auto going up rigidbody.Velocity(Vector2.up*2);  
3)one hand control: 손맛있는 한손조작 Level Design: 아래서 위로 

4) EnemySpawner . cs 보완하기

적들이 wave1 , wave2, wave3 형식으로 텀을 가지고 적 뭉치가 스폰되어서, player인 ballrumble를 추적하는 스폰시스템을 구현 하고 싶다. 코드를 한번 봐주시고 보완해주시길 바랍니다.

--------------------------September 15th 2023(Friday) Devlog--------------------------
0) Copilot .setup
unity 2022.3.3 2D vertical shooting game에 Copilot 설치하고 설정하는 방법 알려주세요.
Unity 2D vertical shooting game에 GitHub Copilot을 설치하고 설정하는 과정은 다음과 같습니다. Unity 및 Visual Studio Code (VSCode)를 기반으로 설명하겠습니다. GitHub Copilot은 VSCode 확장 프로그램으로 사용되므로 먼저 VSCode를 설치해야 합니다.
Visual Studio Code 설치:
Visual Studio Code를 다운로드하고 설치합니다. VSCode는 무료이며 GitHub Copilot과의 호환성이 좋습니다.
Unity 프로젝트 열기:
Unity 2D vertical shooting game 프로젝트를 엽니다.
GitHub Copilot 설치:
VSCode를 실행하고 Extensions 탭을 클릭합니다 (사이드바에서 네모 상자 아이콘).
"GitHub Copilot"을 검색하고 설치 버튼을 클릭하여 확장을 설치합니다.
GitHub Copilot 구성:
확장이 설치된 후, VSCode를 다시 시작하면 GitHub Copilot이 활성화됩니다.
GitHub Copilot을 사용하려면 GitHub 구독이 필요합니다. GitHub Copilot을 사용 가능한 상태로 만들려면 GitHub에서 구독을 확인하고 설정해야 합니다.
GitHub Copilot 사용:
Unity 프로젝트의 스크립트 또는 코드 파일을 열고 코드를 작성하십시오.
GitHub Copilot은 코드 작성 중에 도움말 및 코드 추천을 제공합니다. 주석을 달거나 코드 조각을 작성하면 GitHub Copilot이 관련 정보를 제안합니다.
GitHub Copilot은 코드 작성을 더 쉽게 만들어주는 도구이며, Unity 또는 다른 개발 플랫폼에서 사용할 수 있습니다. 위의 단계를 따라 설치 및 활성화한 후 코드 작성 시 도움을 받을 수 있어야 합니다. Unity 특정 기능을 지원하거나 프로젝트 설정에 대한 특별한 설정이 필요한 경우 Unity의 공식 문서 및 GitHub Copilot의 문서를 참조하여 추가 지침을 얻을 수 있습니다.

--------------------------September 13~15th 2023(wed,thurs,friday) Devlog--------------------------
1) auto aim, shooting, 2)auto going up rigidbody.Velocity(Vector2.up*2);  3)one hand control손맛있는 한손조작 Level Design: 아래서 위로 

4) EnemySpawner . cs 하기 코드 폐기
/*using UnityEngine;
public class EnemySpawner : MonoBehaviour
{
    private void Update()
    {
        if (Time.time >= nextSpawnTime)
        {
            SpawnEnemy();
            nextSpawnTime = Time.time + 1f / spawnRate;
        }
    }
    void SpawnEnemy(){
        Vector2[] spawnPoints = {
            new Vector2(-gameWorldWidth/2, Random.Range(-gameWorldHeight/2, gameWorldHeight/2)),
            new Vector2(gameWorldWidth/2, Random.Range(-gameWorldHeight/2, gameWorldHeight/2)),
            new Vector2(Random.Range(-gameWorldWidth/2, gameWorldWidth/2), gameWorldHeight/2),
            new Vector2(Random.Range(-gameWorldWidth/2, gameWorldWidth/2), -gameWorldHeight/2)
        };
        Vector2 spawnPosition = spawnPoints[Random.Range(0, spawnPoints.Length)];
        Instantiate(enemyPrefab, spawnPosition, Quaternion.identity);
    }
}*/
--------------------September 11st,12nd 2023(Monday,Tuesday) Devlog--------------------
인후성 독감으로 오한, 몸살, 식은땀 현기증, 복통으로 휴식
--------------------September 9th 2023(Saturday) Devlog----------------------------
1) 에러 버그 챗지피티 문의
unity 2022.3.3 mobile vertical 2D shooting game을 만드는 중인데, 다음과 같이 에러가 나오는데 원인과 해결방법을 알려줘. Blender could not be found. Make sure that Blender is installed and the .blend file has Blender as its 'Open with' application! #0 GetStacktrace(int) #1 DebugStringToFile(DebugStringToFileData const&) #2 ImportToObjects(core::basic_string<char, core::StringStorageDefault<char>> const&, core::hash_map<AssetDatabase::ImporterID, ImporterInfo, core::hash<AssetDatabase::ImporterID>, std::__1::equal_to<AssetDatabase::ImporterID>> const&, dynamic_array<PostprocessorInfo, 0ul> const&, AssetResolveTracker const&, ImportAssetInputs const&, ImportAssetOutputs&, IImportProgress*) #3 ImportAsset(core::hash_map<AssetDatabase::ImporterID, ImporterInfo, core::hash<AssetDatabase::ImporterID>, std::__1::equal_to<AssetDatabase::ImporterID>> const&, dynamic_array<PostprocessorInfo, 0ul> const&, AssetResolveTracker const&, ImportAssetInputs const&, ImportAssetOutputs&, IImportProgress*) #4 ImportAssetWithAutoReleasePool(core::hash_map<AssetDatabase::ImporterID, ImporterInfo, core::hash<AssetDatabase::ImporterID>, std::__1::equal_to<AssetDatabase::ImporterID>> const&, dynamic_array<PostprocessorInfo, 0ul> const&, AssetResolveTracker const&, ImportAssetInputs const&, ImportAssetOutputs&, IImportProgress*) #5 AssetImportWorker::Import(AssetResolver&, ImportAssetInputs const&, WorkerImportResponse&, IImportProgress*, bool*) #6 AssetImportManager::ImportInProcess(AssetResolver&, ArtifactKey const&, AssetImportParameters const&, AssetDatabase::ArtifactID&, IImportProgress*, core::hash_set<core::basic_string<char, core::StringStorageDefault<char>>, core::hash<core::basic_string<char, core::StringStorageDefault<char>>>, std::__1::equal_to<core::basic_string<char, core::StringStorageDefault<char>>>>&, CrashedAssetImportsDatabase&) #7 AssetImportManager::Import(core::hash_map<AssetDatabase::ImporterID, ImporterInfo, core::hash<AssetDatabase::ImporterID>, std::__1::equal_to<AssetDatabase::ImporterID>> const&, dynamic_array<PostprocessorInfo, 0ul> const&, AssetResolver&, CategorizedAssets&, IImportProgress*, core::hash_set<UnityGUID, core::hash<UnityGUID>, std::__1::equal_to<UnityGUID>> const&, ImportedAssetsReloadList*, core::hash_set<core::basic_string<char, core::StringStorageDefault<char>>, core::hash<core::basic_string<char, core::StringStorageDefault<char>>>, std::__1::equal_to<core::basic_string<char, core::StringStorageDefault<char>>>>&, CrashedAssetImportsDatabase&, OnDemandScheduler&, bool) #8 RefreshInternalV2(AssetDatabase::UpdateAssetOptions, ScanFilter const&, InternalRefreshFlagsV2) #9 StopAssetImportingV2Internal(AssetDatabase::UpdateAssetOptions, InternalRefreshFlagsV2, ScanFilter const*, char const*) #10 RefreshV2(AssetDatabase::UpdateAssetOptions) #11 AssetDatabase::Refresh(AssetDatabase::UpdateAssetOptions) #12 CallbackArray::Invoke() #13 ProfilerCallbackInvoke<CallbackArray, &GlobalCallbacks::tickEditor>::Invoke(char const*) #14 Application::TickTimer() #15 -[EditorApplication TickTimer] #16 __NSFireTimer #17 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ #18 __CFRunLoopDoTimer #19 __CFRunLoopDoTimers #20 __CFRunLoopRun #21 CFRunLoopRunSpecific #22 RunCurrentEventLoopInMode #23 ReceiveNextEventCommon #24 _BlockUntilNextEventMatchingListInModeWithFilter #25 _DPSNextEvent #26 -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] #27 -[NSApplication run] #28 NSApplicationMain #29 EditorMain(int, char const**) #30 main #31 start
ChatGPT
이 에러는 Unity가 Blender에 연결되어 있는 .blend 파일을 임포트하려고 했을 때 발생합니다. Unity는 직접 .blend 파일을 임포트할 수 있는데, 이는 내부적으로 Blender를 사용하여 파일을 FBX로 변환한 후 해당 FBX를 임포트합니다. 그러므로 Blender가 설치되어 있지 않거나 올바르게 연결되어 있지 않으면 이와 같은 에러가 발생합니다.
해결 방법:
Blender 설치: Blender가 컴퓨터에 설치되어 있는지 확인하세요. 설치되어 있지 않다면 Blender 공식 웹사이트에서 다운로드하여 설치하세요.
파일 연결 확인: .blend 파일을 우클릭하고 '열기 방법 선택' (또는 해당하는 메뉴)을 선택한 후, Blender로 열 수 있는지 확인하세요. Blender로 연결되어 있지 않다면 Blender를 기본 애플리케이션으로 설정하세요.
Unity 재시작: Unity를 재시작한 후 .blend 파일을 다시 임포트해 보세요.
FBX 사용: 여전히 문제가 발생한다면, Blender에서 파일을 직접 FBX 형식으로 내보낸 후 Unity에서 해당 FBX 파일을 임포트하는 방법도 있습니다.
이러한 단계를 따르면 문제를 해결할 수 있어야 합니다.
--------------------------September 8,9th 2023(Friday,Weekend) Devlog----------------------------
오늘 오늘 목표: 
1) 오즈라엘 강의 듣기
fff쉐이더 적용해보기0,

2)스폰 시스템만들기, (레벨디자인234아래에서 위로)

3)auto going up rigidbody.Velocity(Vector2.up*2);

--------------------------September,6th 2023(수 Wed,Th) Devlog ----------------------------
지금 기능 들만 만들고 놓고 (제네널 템플릿)레벨디자인, 밸런스 디자인은 전혀 안한 상태에요
일단 손맛이 이 게임의 중요한 요소인데 개발내내 계속 알앤디 할듯 하군요..  게임을 해보니  다운웰 처럼 하단을 쏘는 형태 즉 전폭기의 달린 뒷기관총 같이 되어야 한다. 따라오는 것들을 추격해오는 것들을 처치하는 것. 위에 레벨보다 올라오는 것에 대한 레벨디자인이 필요한듯 하다
1) bug fix
2) Level design
 /*  하기 코드 폐기 bJoysitck_contorl is terminated
        moveInput_keyboard = Input.GetAxisRaw("Horizontal");
        Vector2 dir = new Vector2(moveInput_keyboard, 0);

     

        if (bJoysitck_contorl == false)
        {
            bJumpOK = true;
            fDelayDuration = 0f;
            transform.position += (Vector3)dir * fPCSpeed * Time.deltaTime;
            rb.AddTorque(-moveInput_keyboard * fPCSpeed, ForceMode2D.Force);
            float horizontalInput = Input.GetAxisRaw("Horizontal");
            if (horizontalInput != 0)
                transform.Find("DIO").transform.Rotate(0, 0, -3 * horizontalInput);
        }
        else if (bJoysitck_contorl == true)
        {

          
            float horizontalInput = joystick.Horizontal;
            if (horizontalInput != 0)
                transform.Find("DIO").transform.Rotate(0, 0, rotationAmount * horizontalInput);
            
        }
        */


--------------------------September 3rd,4th,5th 2023(Sun,Mon) Devlog ----------------------------
게임을 해보니  다운웰 처럼 하단을 쏘는 형태 즉 전폭기의 달린 뒷기관총 같이 되어야 한다. 
따라오는 것들을 추격해오는 것들을 처치하는 것. 
위에 레벨보다 올라오는 것에 대한 레벨디자인이 필요한듯 하다.

1)지금 기능 들만 만들고 놓고 (제네널 템플릿)


2)레벨디자인, 밸런스 디자인


3) 조작감 
일단 손맛이 이 게임의 중요한 요소인데 개발내내 계속 알앤디 보완




TimelineSettings.asset 파일은 유니티 프로젝트에서 타임라인 설정과 관련된 정보를 저장하는 파일입니다. 타임라인은 Unity의 시퀀싱 도구로, 애니메이션, 오디오, 이벤트 등을 시간에 따라 배치하고 조정할 수 있습니다.
YAML 파일 내용을 살펴보면, 다음과 같은 항목들이 있습니다:
assetDefaultFramerate와 m_DefaultFrameRate: 이것은 타임라인의 기본 프레임레이트를 설정하는 값입니다. 여기서는 60으로 설정되어 있습니다.
m_ObjectHideFlags, m_CorrespondingSourceObject, m_PrefabInstance, m_PrefabAsset, m_GameObject: 이러한 값들은 Unity 내부에서 객체와 관련된 메타데이터를 저장합니다.
m_Script: 이것은 해당 설정이 어떤 스크립트에 의해 관리되는지에 대한 정보입니다. 여기서는 guid 값과 fileID 값으로 스크립트를 참조하고 있습니다.
이 파일은 주로 유니티 에디터 내에서 자동으로 생성되며 관리됩니다. 일반적으로 이 파일을 수동으로 편집할 필요는 없습니다.
코드에서 bJoysitck_contorl 변수를 수정하고 싶으시다면, 이 변수의 상태에 관계 없이 키보드와 가상 조이스틱 모두를 항상 사용할 수 있게 코드를 변경할 수 있습니다. 예를 들어, FixedUpdate 메소드와 Update 메소드에서 bJoysitck_contorl 변수의 체크를 제거하고, 둘 다 항상 작동하게 설정하면 됩니다.






----------------------------September 2nd 2023(Sat) Devlog ------------------------------
1Give up to submit application to beber game competition.
2trash code (temp)

public class GameManager : Singleton<GameManager>
{
    public ballrumble ballrumble_pc; //현재 사용인함
    public UIManager UIManager;

    public float LeftLimit = -22;
    public float RightLimit = 21;
    public float TopLimit = 9.8f;
    public float BottomLimit = -9.5f; 
 
    public GameState GS;

    public  int nLevel = 1;
    public  int p1Score = 0;
    public  int nGameScore_current;
    public  int nGameScore_Best;

    //도전과제용 변수
    public float fGametime; //플레이타임
    public int UseBullet;   //총알사용개수
    public int KillEnemy;   //적 사망
    public int Die;         //나 사망
    public int HiddenItems; //히든아이템 찾은 개수
    // [HideInInspector] public InitializeBase[] initBaseObjs = null;
    //최적화 변수
    public MainCamera cam;
    private GameObject[] ExitEffect; // 골이펙트
    //무적모드
    private Rect PowerFullWindowRet = new Rect(Screen.width * 0.5f, Screen.height * 0.5f, 200, 200);
    private GUIStyle g = new GUIStyle();
    private float powerTextTime = 1.5f; // 화면에 표시시간
    private float powerTime;
    public int WinPlayer;
    protected override void Awake()
    {
        base.Awake();  // Call the Singleton's Awake()

        nLevel = 1;
        g.fontSize = 50;
        g.normal.textColor = Color.white;
        g.alignment = TextAnchor.MiddleCenter;

        //바운더리 사이즈 세팅
        /*
        LeftLimit = GameObject.Find("Boundary(Left)").transform.position.x;
        RightLimit = GameObject.Find("Boundary(Right)").transform.position.x;
        TopLimit = GameObject.Find("Boundary(Top)").transform.position.y;
        BottomLimit = GameObject.Find("Boundary(Bottom)").transform.position.y;
        */
    }
    // Start is called before the first frame update
    void Start()
    {
        /*
        cam = GameObject.FindGameObjectWithTag("MainCamera");
        if (cam == null)
        {
            Debug.LogError("MainCamera not found. Make sure the tag is set correctly.");
        }

        UIManager = GameObject.FindObjectOfType<UIManager>();
        if (UIManager == null)
        {
            Debug.LogError("UIManager not found. Make sure the UIManager script is attached to a GameObject.");
        }
        */

        //        ExitEffect = GameObject.FindGameObjectsWithTag("ExitEffect");
        //     if (loadingScreen == null)
        //         GameObject.Find("Lodingpage");
        //     loadingScreen.SetActive(false);
        GameInit();

    }

    public void GameInit() // 게임 리셋시, 초기화 함수
    {
        /*
        if (null != SoundManager.Instance)
        SoundManager.Instance.PlayBackgroundMusic(nLevel-1);*/
        Time.timeScale = 1f;
        nGameScore_current = 0;
        nGameScore_Best = 0;


        Die = 0;    //내가 죽은 회수는 계속 누적해야 하므로.
        fGametime = 0;
        UseBullet = 0;
        KillEnemy = 0;
        HiddenItems = 0;
       /* MsgDirector.nStage_count = 0;
        nLevel = SceneManager.GetActiveScene().buildIndex;
        
     

        if (camera && camera.GetComponent<BlurBehind>().radius > 0f)
            camera.GetComponent<BlurBehind>().radius = 0f;

        if (initBaseObjs.Length > 0)
        {
            for (int cnt = 0; cnt < initBaseObjs.Length; cnt++)
                initBaseObjs[cnt].InitializeStart();
        }
       */
        //살아있는 총알들은 모두 삭제한다.
//        GameObject[] Missiles = GameObject.FindGameObjectsWithTag("Missile");
//        GameObject[] EMissiles = GameObject.FindGameObjectsWithTag("EMissile");
 /*     
        if (EMissiles.Length > 0)
        {
            for (int cnt = 0; cnt < EMissiles.Length; cnt++)

                DestroyImmediate(EMissiles[cnt]);

        }
        if (Missiles.Length > 0)
        {
            for (int cnt = 0; cnt < Missiles.Length; cnt++)
                DestroyImmediate(Missiles[cnt]);

        }
        if (ExitEffect.Length > 0)
        {
            for (int i = 0; i < ExitEffect.Length; i++)
                ExitEffect[i].SetActive(false);
        }
 */
        GS = GameState.Ready;
    }

    public void AddScore()
    {
        nGameScore_current += 1;

    }

    public void AddScore(int Score)
    {
        nGameScore_current += Score;

    }
    // Update is called once per frame
    void Update()
    {

       // if(fbird.bIsDead)          
  
        //Show bullet count on GUI
      
            switch (GS)
            {
                case GameState.Ready: //150929 현재 사용하지 않는 코드
                    break;

                case GameState.Play:
                    if (fGametime < 1000)
                        fGametime += Time.deltaTime;

        

                break;

                case GameState.Pause:
          //          if (camera.GetComponent<BlurBehind>().radius < 2.1f) camera.GetComponent<BlurBehind>().radius += Time.smoothDeltaTime * 15f;
                    Time.timeScale = 0f;

                    break;

                case GameState.Clear:
                    Time.timeScale = 0.7f;
                UIManager.GameClear();
                //     float fradiusvalue = GameObject.FindGameObjectWithTag("MainCamera").GetComponent<BlurBehind>().radius;

                /*  if (camera.GetComponent<BlurBehind>().radius < 2.1f)
                      camera.GetComponent<BlurBehind>().radius += Time.smoothDeltaTime * 15f;
                   GameObject.FindGameObjectWithTag("MainCamera").GetComponent<BlurBehind>().radius += Time.deltaTime*10;
                */

               // if (Input.GetKeyDown(KeyCode.Space) ) //|| Input.GetButtonDown(btnNum))
                //        Clear();
                    break;



                case GameState.Gameover:
                    Time.timeScale = 0.05f;
                  /*  if (camera.GetComponent<BlurBehind>().radius < 2.1f)
                        camera.GetComponent<BlurBehind>().radius += Time.smoothDeltaTime * 15f; */
                    if (Input.GetKeyDown(KeyCode.Space) )// || Input.GetButtonDown(btnNum))
                    {
                        Die++;
                        GameInit();
                    }
                    break;


            }

        


    }

    public void Clear()
    {
    
        nLevel++;
        Debug.LogFormat("Loading a new level {0}...", nLevel);
        if( nLevel < SceneManager.sceneCount)
        LoadLevel(nLevel);
        else
            SceneManager.LoadScene(0);




    }

    public void LoadLevel(int nlevel)
    {

        SceneManager.LoadScene(nlevel);
      //  SceneManager.LoadScene(level[ResourceManager.Instance.levelnum++]); //임의 레벨 하고싶을때

    }


    public void GameOver()
    {

  
        SoundManager.Instance.GameOver();
        GS = GameState.Gameover;

    }
    // 게임오버를 위한 함수.
     IEnumerator IGameOver()
    {

        GS = GameState.DieDeley;
        yield return new WaitForSeconds(1.2f);
        SoundManager.Instance.GameOver();
        GS = GameState.Gameover;

    }
}

—--------------------------------------------------------------------------------------------------------------------
 /*
        if (FindObjectsOfType<ResourceManager>().Length == 0)
        {
            GameObject TempResource = new GameObject("TempResource");
            TempResource.AddComponent<ResourceManager>().Init();
        }
        // Advertisemnet.Initialize("00000"); // Unity Ads Codes
        initBaseObjs = (InitializeBase[])FindObjectsOfType(typeof(InitializeBase));
        */

1)2D 쉐이더 studying
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/Lights-2D-intro.html
    /*       Debug.LogFormat("Level: {0} --> {1}", nLevel - 1, nLevel);
            int nHighestLevel = PlayerPrefs.GetInt(SaveLoadManager.CLEAR_SINGLE_STAGE_PREF_KEY);

            Debug.LogFormat("Highest Level (OLD): {0}", nHighestLevel);

            if (nLevel - 1 > nHighestLevel) // && GM == GameMode.SINGLE)
            {
                nHighestLevel = nLevel - 1;
               // PlayerPrefs.SetInt(SaveLoadManager.CLEAR_SINGLE_STAGE_PREF_KEY, nHighestLevel);
               // PlayerPrefs.Save();
                Debug.LogFormat("Highest Level updated to {0}", nHighestLevel);
                Debug.LogFormat("Trying GPGSIds.leaderboard_who_is_best_runner = {0}...", nHighestLevel);
            
                if (Application.isEditor == false)
                {
                    Social.ReportScore(nHighestLevel, GPGSIds.leaderboard_who_is_best_runner, (bool _send) =>
                    {
                        Debug.LogFormat("Trying GPGSIds.leaderboard_who_is_best_runner = {0} sent result {1}", nHighestLevel, _send);
                    });
                }
                else
                {
                    Debug.LogFormat("GPGSIds.leaderboard_who_is_best_runner = {0} (Not logged in)", nHighestLevel);
                }
            
            }    */
----------------------------August 30th 2023(Thur) Devlog ------------------------------
1)2D 쉐이더 studying
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/Lights-2D-intro.html

2) AI BGM Maker Musicgen,Soundraw
2
----------------------------August 24th 2023(Thur) Devlog ------------------------------
post processing
https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/Quick-start.html


URP 2d shadow신규 2D URP 프로젝트
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@16.0/manual/Lights-2D-intro.html


----------------------------August 23rd 2023(Wed) Devlog ------------------------------
1)오즈라엘 강의 2D 쉐이더 studying
https://www.youtube.com/watch?v=8-KkseDSXeI
2D 쉐이더 타임라인
0:00:00 오프닝 0:01:58 이번 알쓸유잡 개요
0:07:05 신규 2D URP 프로젝트 - Happy Harvest 소개
0:16:43 유니티의 2D 구조  0:24:25 쉐이더란 무엇인가?
0:27:40 렌더링 파이프라인의 기초    0:36:26 2D의 메테리얼과 쉐이더
0:40:45 유니티 2D URP 기본 쉐이더	0:43:53 벡터의 의미와 활용
0:54:40 2D 쉐이더 그래프 기초 - 타일링과 오프셋
0:58:46 다른 정보로서 텍스쳐 활용
1:05:52 쉐이더 그래프 실습 - 2D 쉐이더 그래프 시작하기
1:17:44 쉐이더 그래프 실습 - 수직으로 등장하는 이펙트
1:26:11 쉐이더 그래프 실습 - 빛나는 글로우 영역 추가
1:32:38 쉐이더 그래프 실습 - 노이즈를 응용한 디졸브 이펙트
1:37:02 스크립트로 메테리얼 컨트롤하는 방법,1:41:49 물 쉐이더 그래프 분석
2D 쉐이더 타임라인 0:00:00 오프닝 0:01:58 이번 알쓸유잡 개요 0:07:05 신규 2D URP 프로젝트 - Happy Harvest 소개 0:16:43 유니티의 2D 구조 0:24:25 쉐이더란 무엇인가? 0:27:40 렌더링 파이프라인의 기초 0:36:26 2D의 메테리얼과 쉐이더 0:40:45 유니티 2D URP 기본 쉐이더 0:43:53 벡터의 의미와 활용 0:54:40 2D 쉐이더 그래프 기초 - 타일링과 오프셋 0:58:46 다른 정보로서 텍스쳐 활용 1:05:52 쉐이더 그래프 실습 - 2D 쉐이더 그래프 시작하기 1:17:44 쉐이더 그래프 실습 - 수직으로 등장하는 이펙트 1:26:11 쉐이더 그래프 실습 - 빛나는 글로우 영역 추가 1:32:38 쉐이더 그래프 실습 - 노이즈를 응용한 디졸브 이펙트 1:37:02 스크립트로 메테리얼 컨트롤하는 방법 1:41:49 물 쉐이더 그래프 분석 1:50:04 마무리
2) 오즈라엘강의2
https://www.youtube.com/watch?v=6X3px0Yip-k&t=569s

https://www.youtube.com/watch?v=F5l8vP90EvU

----------------------------August 22nd 2023(Tue) Devlog ------------------------------
    IEnumerable SpawnLoop()
    {
        while (true)
        {
            Debug.Log("출력 ");
            yield return new WaitForSeconds(1f);
        }
    }
    IEnumerable corutineEx()
    {
        for(; ; )
        {
            yield return new WaitForSeconds(1f);
        }


       // yield return new WaitForSeconds(1f);
    }
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityEngine.UIElements;
public enum AxisOptions { Both, Horizontal, Vertical }
public class Joystick : MonoBehaviour, IPointerDownHandler, IDragHandler, IPointerUpHandler
{
    public float Horizontal { get { return (snapX) ? SnapFloat(input.x, AxisOptions.Horizontal) : input.x; } }
    public float Vertical { get { return (snapY) ? SnapFloat(input.y, AxisOptions.Vertical) : input.y; } }
    public Vector2 Direction { get { return new Vector2(Horizontal, Vertical); } }


    public float HandleRange
    {
        get { return handleRange; }
        set { handleRange = Mathf.Abs(value); }
    }


    public float DeadZone
    {
        get { return deadZone; }
        set { deadZone = Mathf.Abs(value); }
    }


    public AxisOptions AxisOptions { get { return AxisOptions; } set { axisOptions = value; } }
    public bool SnapX { get { return snapX; } set { snapX = value; } }
    public bool SnapY { get { return snapY; } set { snapY = value; } }


    [SerializeField] private float handleRange = 1;
    [SerializeField] private float deadZone = 0;
    [SerializeField] private AxisOptions axisOptions = AxisOptions.Both;
    [SerializeField] private bool snapX = false;
    [SerializeField] private bool snapY = false;


    [SerializeField] protected RectTransform background = null;
    public RectTransform handle = null;
    private RectTransform baseRect = null;


    private Canvas canvas;
    private Camera cam;


    private Vector2 input = Vector2.zero;
public float fPressTime;
public bool bGstate;


    protected virtual void Start()
    {
        HandleRange = handleRange;
        DeadZone = deadZone;
        baseRect = GetComponent<RectTransform>();
        canvas = GetComponentInParent<Canvas>();
        if (canvas == null)
            Debug.LogError("The Joystick is not placed inside a canvas");
        Vector2 center = new Vector2(0.5f, 0.5f);
        background.pivot = center;
        handle.anchorMin = center;
        handle.anchorMax = center;
        handle.pivot = center;
        handle.anchoredPosition = Vector2.zero;
        bGstate = false;
    }
    public virtual void OnPointerDown(PointerEventData eventData)
    {
        OnDrag(eventData);
    }


    public void OnDrag(PointerEventData eventData)
    {
        cam = null;
        if (canvas.renderMode == RenderMode.ScreenSpaceCamera)
            cam = canvas.worldCamera;


        Vector2 position = RectTransformUtility.WorldToScreenPoint(cam, background.position);
        Vector2 radius = background.sizeDelta / 2;
        input = (eventData.position - position) / (radius * canvas.scaleFactor);
        FormatInput();
        HandleInput(input.magnitude, input.normalized, radius, cam);
        handle.anchoredPosition = input * radius * handleRange;
    }






    protected virtual void HandleInput(float magnitude, Vector2 normalised, Vector2 radius, Camera cam)
    {
        if (magnitude > deadZone)
        {
            
            if (magnitude > 1)
                input = normalised;           
                fPressTime += Time.deltaTime;
                if(fPressTime > 1.5f && bGstate == false)
                {
                    fPressTime = 0f;
                    handle.GetComponent<Image>().color = Color.red;
                    bGstate = true;
                }


        }
        else
            input = Vector2.zero;
    }


    private void FormatInput()
    {
        if (axisOptions == AxisOptions.Horizontal)
            input = new Vector2(input.x, 0f);
        else if (axisOptions == AxisOptions.Vertical)
            input = new Vector2(0f, input.y);
    }


    private float SnapFloat(float value, AxisOptions snapAxis)
    {
        if (value == 0)
            return value;


        if (axisOptions == AxisOptions.Both)
        {
            float angle = Vector2.Angle(input, Vector2.up);
            if (snapAxis == AxisOptions.Horizontal)
            {
                if (angle < 22.5f || angle > 157.5f)
                    return 0;
                else
                    return (value > 0) ? 1 : -1;
            }
            else if (snapAxis == AxisOptions.Vertical)
            {
                if (angle > 67.5f && angle < 112.5f)
                    return 0;
                else
                    return (value > 0) ? 1 : -1;
            }
            return value;
        }
        else
        {
            if (value > 0)
                return 1;
            if (value < 0)
                return -1;
        }
        return 0;
    }


    public virtual void OnPointerUp(PointerEventData eventData)
    {
        input = Vector2.zero;
        handle.anchoredPosition = Vector2.zero;
    }


    protected Vector2 ScreenPointToAnchoredPosition(Vector2 screenPosition)
    {
        Vector2 localPoint = Vector2.zero;
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(baseRect, screenPosition, cam, out localPoint))
        {
            Vector2 pivotOffset = baseRect.pivot * baseRect.sizeDelta;
            return localPoint - (background.anchorMax * baseRect.sizeDelta) + pivotOffset;
        }
        return Vector2.zero;
    }
}
public class DynamicJoystick : Joystick
{
    public float MoveThreshold { get { return moveThreshold; } set { moveThreshold = Mathf.Abs(value); } }

    [SerializeField] private float moveThreshold = 1;

    protected override void Start()
    {
        MoveThreshold = moveThreshold;
        base.Start();
      //  background.gameObject.SetActive(false);
    }

    public override void OnPointerDown(PointerEventData eventData)
    {
        background.anchoredPosition = ScreenPointToAnchoredPosition(eventData.position);
      //  background.gameObject.SetActive(true);
        base.OnPointerDown(eventData);
    }

    public override void OnPointerUp(PointerEventData eventData)
    {
     //   background.gameObject.SetActive(false);
        base.OnPointerUp(eventData);
    }

    protected override void HandleInput(float magnitude, Vector2 normalised, Vector2 radius, Camera cam)
    {
        if (magnitude > moveThreshold)
        {
            Vector2 difference = normalised * (magnitude - moveThreshold) * radius;
            background.anchoredPosition += difference;
        }
        base.HandleInput(magnitude, normalised, radius, cam);
    }

}



※ 국내 최초 오픈 소스, 오픈 기획 프로젝트 (누구나 기획에 참여 가능)
–문서 수정 및 개발자 본인 외 다른 분은 이 공간에 기획 부분(의견, 기획내용,피드백, 코멘트,etc)  적어주시면 개발자에게 전달되어 적용될 확률이 있습니다.
https://seokcess.notion.site/a77b7c28496e4311be552b7317abf13c
https://seokcess.notion.site/e5b44e8ed4e341549548553519895e87?v=26a1be64652f4745b4aa87111725b56c




--------------------------August 21th 2023(Mon,Tue) Devlog ----------------------------
    private void FireMissile()
    {
        GameObject missile = Instantiate(missilePrefab, missileSpawnPoint.position, Quaternion.identity);
        Rigidbody2D missileRb = missile.GetComponent<Rigidbody2D>();
        Vector2 shootDirection = transform.Find("DIO").up;
        missileRb.AddForce(shootDirection * missileForce, ForceMode2D.Impulse);
    }
    //타임어택 시간10sec 지나면 피 한칸 씩 줄어드는 codes
       /*
                   if (bIsDead != true)
                   {
                       if (fComboTime < fMaxComboTime)
                           fComboTime += Time.deltaTime;

                       if (fComboTime >= fMaxComboTime && list_ComboStack.Count > 0)
                       {
                           list_ComboStack.RemoveAt(list_ComboStack.Count - 1);
                           fComboTime = 0;
                       }

                   }
       */
--------------------------August 14,16th 2023(Mon,Wed) Devlog ----------------------------
 1) 게임 핵심요소(메커닉1): 탄을 쏘는 역학 구현중 


하기 코드 폐기
    /*     // 에임을 처리하는 함수
    void HandleAim(Touch touch)
    {
        // 월드 좌표로 마우스 위치를 변환합니다.
        Vector3 aimPosition = Camera.main.ScreenToWorldPoint(touch.position);
        aimPosition.z = 0f; // 2D 게임에서는 z 좌표를 0으로 고정합니다.

        // 여기에서 원하는 작업을 수행하고 에임 위치에 따라 총알이나 레이저를 발사하거나 기타 동작을 수행합니다.
        // 예시: 총알 발사 함수 호출
        // ShootBullet(aimPosition);

        // 예시: 캐릭터를 에임 위치로 회전시키기
        // Vector3 lookDirection = aimPosition - transform.position;
        // float angle = Mathf.Atan2(lookDirection.y, lookDirection.x) * Mathf.Rad2Deg;
        // transform.rotation = Quaternion.Euler(0f, 0f, angle);
    }

/*
//움직이는 코드
        // transform.Translate(new Vector2(joystick.Horizontal, joystick.Vertical) * fPCSpeed);
        // transform.Translate(DynamicJoystick.Horizontal, joystick.Vertical);
        /*
        // Player movement
                float vert = Input.GetAxis("Vertical");
                float hori = Input.GetAxis("Horizontal");

                transform.Translate(new Vector2(hori, vert));
        */
        // bounce the player off the bounds
        //	if(Mathf.Abs(transform.position.x) > 10f)
        //			vel.x = -vel.x;		
        //		if(Mathf.Abs(transform.position.y) > 10f)
        //			vel.y = -vel.y;

        /*
                if(Input.GetKeyDown (KeyCode.G)){
                    sfRenderer.enabled = !sfRenderer.enabled;
                }

                // headlights!
                if(Input.GetKeyDown(KeyCode.F)){
                    headlightOn = !headlightOn;
                }
         */

        // else
        // {  rb.velocity = new Vector2(moveInput * 3, rb.velocity.y); }



/*
        // 마우스 입력을 처리합니다.
        if (Input.GetMouseButtonDown(0))
        {
            // 마우스를 클릭하면 터치 아이디를 할당합니다.         
            touchId = 0;
        }
        else if (Input.GetMouseButtonUp(0))
        {
            // 마우스를 뗄 때 터치 아이디를 해제합니다.
            touchId = -1;
        }

        // 마우스가 눌려있는 동안 터치 이동을 처리합니다.
        if (touchId != -1)
        {
            // 터치 아이디에 해당하는 터치 정보를 가져옵니다.
            Touch touch = new Touch();
            touch.fingerId = touchId;
            touch.position = Input.mousePosition;
            touch.phase = TouchPhase.Moved;

            // 마우스 위치를 에임으로 사용하는 함수를 호출합니다.
            HandleAim(touch);
        }
*/


/*
            // Rotate left
            if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
            {
                transform.Find("DIO").transform.Rotate(0, 0, -rotationAmount);
            }

            // Rotate right
            if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
            {
                transform.Find("DIO").transform.Rotate(0, 0, rotationAmount); // Negative because right rotation is counter-clockwise in Unity's coordinate system
            }
            */



void Update()
{
   if (Input.GetKeyDown(KeyCode.Space))
        {
            if (bJumpOK == true)// && isGrounded)
            {
                // Calculate the direction aiming from the object to the Aim
                Vector2 dic_aim = Aim.transform.position - this.transform.position;

                // Reverse the direction of dic_aim
                dic_aim = -dic_aim;

                rb.AddForce(dic_aim.normalized * fJumpPower, ForceMode2D.Impulse); //this.rb.velocity = new Vector2(forwardSpeed, 0);
                                                                                   // animator.SetTrigger("ani_fly");
                gameObject.GetComponent<SpriteRenderer>().color = Color.red;

                Dash_fDeltatime = 0;
                fFillTimer = 0f;
                bJumpOK = false;
                FireMissile(); // 미사일 발사 함수 호출 call the missile launch function
            }
        }
         
            transform.position += (Vector3)dir* fPCSpeed * Time.deltaTime;
            rb.AddTorque(-moveInput_keyboard * fPCSpeed, ForceMode2D.Force);    // 객체를 굴리기 위해 토크 적용. 올바른 방향으로 구르기 위해 음수 값 사용

            // Rotate left
            if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
            {
                transform.Find("DIO").transform.Rotate(0, 0, rotationAmount);
            }

            // Rotate right
            if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
            {
                transform.Find("DIO").transform.Rotate(0, 0, -rotationAmount); // Negative because right rotation is counter-clockwise in Unity's coordinate system
            }

}
        

below Codes 폐기
﻿   void FillAlpha() //구현 필요 
    {
        currentAlpha = Mathf.Clamp01(fFillTimer / fillDuration * alphaIncreaseRate);
        spriteRenderer.color = new Color(this.GetComponent<SpriteRenderer>().color.r, this.GetComponent<SpriteRenderer>().color.g,

            this.GetComponent<SpriteRenderer>().color.b, currentAlpha);
    }


3)게임 핵심(메커닉2) : 위에 벽 깨는 역학:
4) 보스전 - 55Cs초밥어부의 black sushi
아래 코드 버림(Ballrumble.cs)
    /*
       Quaternion rotation = this.transform.rotation;

       // 현재 오브젝트의 Z 축 회전 값을 오일러 각으로 변환합니다.
       float angle = rotation.eulerAngles.z;
       //float angle = rb.rotation;
       //  angle = Mathf.Clamp(angle, -90, 90);

       // 각도를 기준으로 발사 방향 벡터를 계산합니다.
       Vector2 jumpDirection = new Vector2(Mathf.Cos(angle * Mathf.Deg2Rad), Mathf.Sin(angle * Mathf.Deg2Rad));

       rb.AddForce(jumpDirection * Vector2.up* fJumpPower, ForceMode2D.Impulse);  //this.rb.velocity = new Vector2(forwardSpeed, 0);
       */
----------------------August 10,11,14th 2023(Thur,Fri) Devlog ----------------------------
오늘 이터레이션 : 구글상점페이지 만들기, 스테이지1 2 만들기 게임상테 만들기 적1만들기

tasks : 구글상점페이지 만들기, 
스테이지1, 2 만들기 
gamemanager 게임 상태 만들기 

적1만들기
적 설계하기.
---------------------------August 5,9th 2023(Mon~Wednesday) Devlog ------------------------------
버추얼 조이스틱 만들어 보자 . 머리를 써서








upperwell : 볼럼블의 모험 기획서 (ver 0.2)
단시간 내에 벽을 뚫어 높이 올라가자 : 심연의 오마카세를 탈출하자
﻿
바뀐 사항 (뉴스)
1. 무의식-
모바일 게임 '초밥키우기'에서 떠돌던 볼럼블은 의문의 사고로 심연의 お任せ(오마카세)까지 추락하게 됩니다.
심연의 오마카세는 초어의 무의식인 55CS초밥어부가 창조된 공간이자 그 자체인 초밥키우기 세상의 끝자락(심연)입니다,
이 심연과 나락 속에서 '잉여'라는 매개로 초키 세상 온갖모든 것들이 이 곳을 거쳐 존재하게 되었습니다. 밥풀뭉치의 밥알이 몇개인지, 왜 2개의 초밥을 합치면 다른 초밥이 되는지, 이 초밥키우기의 모든 것들은 이 ‘잉여’로부터 시작되었습니다.
(GM초밥어부와 무의식인 55Cs초밥어부)

(초밥키우기 유니버스의 끝자락인, 심연의 お任せ)
2. 볼럼블 의 정체
플레이어는 볼럼블이 주인공으로 등장하여, 플레리어는 이 파란색 볼럼블을 조작하게 됩니다. 하지만 껍데리를 씌울 예정입니다.
사실 볼럼블의 멀티유니버스의 꼬레아의 초전도체 코어 그자체 입니다.
(주인공 볼럼블은 사실 아래 기계 사실의 초전도체 코어였다.)

볼럼블은 공허와 심연이 가득한 곳에서 나와, 노잼 게임에서 예스잼게임,대작게임, 갓게임까지 올라가기 위한 여정입니다.
1. 개요매혹적인 트위스트를 선사하는 모바일 게임.
upperwell는 중독성 있는 하이퍼 캐주얼 게임으로, 벽을 부수고, 빠르게 올라가고, 인상적인 콤보를 쌓는 게임

upperwell은 파란색 볼럼블을 조종하게 하는 하이퍼 캐주얼 모바일 게임입니다. 볼럼블을 점프하여  벽을 뚫고, 가속하여 가능한한,  빠르게 위로 올라가고, 생명게이지(HP)인  콤보게이지를 유지 할 수 있도록  역동적인 게임 플레이 메커니즘을 추구합니다.



2. 세계관-  심연의 お任せ(오마카세)부터 탈출하여 진정한 나를 찾아 떠나는 여정
모바일 게임 '초밥키우기'에서 떠돌던 볼럼블은 의문의 사고로 심연의 お任せ(오마카세)까지 추락하게 됩니다.
심연의 오마카세는 초어의 무의식인 55CS초밥어부가 창조된 공간이자 그 자체인 초밥키우기 세상의 끝자락(심연)입니다,

이 심연과 나락 속에서 '잉여'라는 매개로 초키 세상 온갖모든 것들이 이 곳을 거쳐 존재하게 되었습니다. 밥풀뭉치의 밥알이 몇개인지, 왜 2개의 초밥을 합치면 다른 초밥이 되는지, 이 초밥키우기의 모든 것들은 이 ‘잉여’로부터 시작되었습니다.
(55Cs초밥어부)
  

(초밥키우기 유니버스의 끝자락인,  심연의 お任せ)
 

플레이어는  파란색 볼럼블(통통볼)이 주인공으로 등장하여, 플레리어는 이 파란색 볼럼블을 조작하게 됩니다.
(주인공 볼럼블)

볼럼블은 공허와 심연이 가득한 곳에서 나와, 노잼 게임에서 예스잼게임,대작게임, 갓게임까지 올라가기 위한 여정입니다.

3. 게임 방법 
upperwell는 간단하면서도 매력적인 개념을 제공합니다. 플레이어는 빛의 요정이 벽을 뚫고 제한된 시간 내에 최대한 높이 올라갈 수 있도록 하는 것입니다.


1) 조작 및 유아이
이 게임은 안드로이드 폰 기반 모바일 게임으로 가상 조이스틱이 있습니다.

플레이어가 파란색 볼럼블을 컨트롤하여 벽을 뚫고, 높은 곳으로 올라가고, 인상적인 콤보를 만드는  것으로 최대한 재미있게 만들어 보려고 합니다



이렇게 upperwell는 간단하면서도 중독성 있는 플레이를 추구합니다. 타임어택 형식으로 볼럼블의 생명인 콤보게이지를 유지하기 위해 계속 위에 있는 벽을 부수면서 콤보게이지를 지속적으로 충전해야 합니다.
 연속 콤보가 길수록 점수 배율이 높아져  보다 높은 점수를 획득 할 수 있습니다.
 2) 게임메커닉 벽을 깨는 역학: 작성중

벽을 


3) 보스전 
55Cs초밥어부의 black sushi
가 있으나 아쉽게도 잉여톤 31회에서는 나오지 않습니다. (중장기적 프로젝트)

4. 레벨디자인 
게임 공간안에 벽, 장애물, 파워업의 새로운 조합하여 또한 다양한 레벨 디자인을 하여 정식 출시가 될 즈음에는 30개 정도의 레벨이 나올 것입니다.







-----------------------------------August 3rd 2023(Wed) Devlog --------------------------------
unity의 2D Game에서 rigidbody의 좌우 이동 조작하는 방법을 Rigidbody의 velocity 속성을 사용하지 않는 코드를 작성해 주세요. 
물리 엔진의 velocity 속성 대신 Rigidbody2D.MovePosition 메서드를 사용하여 Rigidbody의 좌우 이동을 조작할 수 있습니다. MovePosition 메서드를 사용하면 Rigidbody의 위치를 직접 변경할 수 있습니다. 아래 예시 코드는 Input.GetAxis를 사용하여 좌우 이동을 감지하고, Rigidbody2D.MovePosition 메서드를 통해 Rigidbody를 이동시키는 방법을 보여줍니다.
코드폐기using UnityEngine;
public class PlayerMovement : MonoBehaviour
{
    public float moveSpeed = 5f; // 이동 속도


    private Rigidbody2D rb2D;


    void Start()
    {
        rb2D = GetComponent<Rigidbody2D>();
    }


    void Update()
    {
        // 입력을 감지하여 좌우 이동을 처리합니다.
        float horizontalInput = Input.GetAxis("Horizontal");
        Move(horizontalInput);
    }
    void Move(float direction)
    {
        // 이동 방향에 따라 Rigidbody의 위치를 변경하여 이동시킵니다.
        Vector2 currentPosition = rb2D.position;
        Vector2 newPosition = new Vector2(currentPosition.x + direction * moveSpeed * Time.deltaTime, currentPosition.y);
        rb2D.MovePosition(newPosition);
    }
}
위의 코드는 입력 축("Horizontal")의 값을 읽어와 해당 값에 따라 좌우 이동을 수행합니다. Rigidbody2D.MovePosition 메서드를 사용하여 이동을 구현했습니다. 입력 축의 값에 따라 현재 위치에 이동 방향과 이동 속도를 곱한 값을 더하여 새로운 위치를 계산하고, 이를 MovePosition 메서드를 통해 Rigidbody의 위치로 설정하여 이동시킵니다.
이 스크립트를 캐릭터나 이동하는 오브젝트에 부착하면, 입력에 따라 좌우로 움직이게 될 것입니다. 원하는 이동 속도나 이동 방식에 따라 moveSpeed 값을 조정하거나 다른 방식을 사용할 수도 있습니다. Rigidbody를 직접 조작하지 않고 MovePosition 메서드를 사용하므로 물리 엔진의 이점을 포기하게 됩니다. 따라서 움직임이 부드럽지 않을 수 있으며, 이동 중에 다른 물리적 상호작용을 고려하지 않을 수 있습니다. 이를 감안하여 게임에 맞는 적절한 이동 방식을 선택하여 구현하시면 됩니다.
            if( this.rb.position.y <= 5) //하늘에 떠있을떄는 
            {
                this.rb.rotation = Mathf.Clamp(this.rb.rotation, -90f, 90f);
                if (this.rb.rotation > 89 || this.rb.rotation < -89)
                {
                    //this.rb.rotation = Mathf.SmoothStep(this.rb.rotation, 0, Time.deltaTime *12f);
                    // this.rb.rotation = Mathf.SmoothDamp(this.rb.rotation, 0, ref forwardSpeed, Time.deltaTime * 30f);
                     this.rb.rotation = Mathf.SmoothDampAngle(this.rb.rotation, 0, ref forwardSpeed, Time.deltaTime * 30f);
                     this.rb.rotation = 0;
                }
}


prj0 Breakrun 출시완료
https://m.onestore.co.kr/mobilepoc/apps/appsDetail.omp?prodId=0000689063


prj1  네모와디오1 2017 Nemo_DO 출시완료https://play.google.com/store/apps/details?id=com.GGHF.Nemo_DO&hl=ko&gl=US
prj1.5 벌룬라이더 출시완료https://play.google.com/store/apps/details?id=top.plusalpha.balloon&hl=ko
prj2 해녀키우기(copyright of plusalpha studio)
prj3  강무무의모험 (copyright problem문제로 prj drop)
prj3  upperwell : 볼럼블의 모험
prj4  2024 다시 만난 네모와 디오(new 유저들의 호환성 문제 해결)
prj5 네모와디오2 : NEMO’s Pet Hostel
https://www.youtube.com/watch?v=CENcAa2uf8M



prj7 tsla only one shot to mars Prelude to Mars 머스크 뚝배기 온리원
—---------------------------------------------------------
upperwell는 중독성 있는 하이퍼 캐주얼 게임으로, 벽을 부수고, 빠르게 올라가고, 인상적인 콤보를 쌓는 것을 중심으로 진행됩니다. 직관적인 컨트롤, 빠르게 진행되는 액션, 숙련된 게임 플레이에 중점을 둔 이 


 
 
 










(55Cs초밥어부와 초밥키우기 세계의 끝자락인,  심연의 お任せ)









(2) 레벨 디자인:
레벨은 벽, 장애물, 파워업의 새로운 조합 시도

Unity의 Grid 기능을 써봐서 프리팹을 만들도록 하자.









202307052300 : 볼럼블 디버깅 가능하게 키보드 조작 가능하게 신규 인풋매니저 교체할지 결정
202306261800 : bulid apk01
202306250100 : dev log  : apk01 release sdk setup
202306241800 : recent implement : virtual joystick , wall hp
glpat-BixsTpYkAfRsVahhGprb








